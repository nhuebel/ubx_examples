--
-- microblx block library generator
-- Copyright (C) 2014 Enea Scioni <enea.scioni@unife.it>
--
--

local utils = require "utils"

local M = {}

-- Generate the header source file that define a ubx block library.
-- @param fd open file to write to (optiona, default: io.stdout)
-- @param libentry libentry from pkg.libraries, already validated
function generate_module_source(fd,libentry)
  fd = fd or io.stdio
  local res, str = utils.preproc(
[[
/*
 * module function declaration for library $(model.name) header (autogenerated)
 */

#include "$(model.name)_module.h"

int $(model.name)_mod_init(ubx_node_info_t* ni)
{
  int ret;
@ for _,v in pairs(model.blocks) do
  ret=$(v)_mod_init(ni);
  if(ret!=0)
    goto out;
@ end

out:
   return ret;
}

void $(model.name)_mod_cleanup(ubx_node_info_t* ni)
{
@ for _,v in pairs(model.blocks) do
  $(v)_mod_cleanup(ni);
@end
}

]], {table=table, pairs=pairs, model=libentry})

   if not res then error(str) end
   fd:write(str)
end

-- Generate the header source file that define a ubx block library.
-- @param fd open file to write to (optiona, default: io.stdout)
-- @param name name library
function generate_module_header(fd,name)
  fd = fd or io.stdout
  local res, str = utils.preproc(
[[
/*
 * module function declaration for library $(name) header (autogenerated)
 */
 
#include <ubx.h>

// Initialization and cleanup function declaration
int $(name)_mod_init(ubx_node_info_t* ni);
void $(name)_mod_cleanup(ubx_node_info_t* ni);


/* declare module init and cleanup functions, so that the ubx core can
 * find these when the module is loaded/unloaded.
 * Please edit your license in macro LICENSE_SPDX */
UBX_MODULE_INIT($(name)_mod_init)
UBX_MODULE_CLEANUP($(name)_mod_cleanup)
UBX_MODULE_LICENSE_SPDX(GPL-2.0+)

]], {table=table,pairs=pairs,name=name})

  if not res then error(str) end
  fd:write(str)
end


-- exports
M.generate_module_source = generate_module_source
M.generate_module_header = generate_module_header

return M