/*
 * random_walk_cblock microblx function block (autogenerated, don't edit)
 */

#include <ubx.h>
#include <stdlib.h>

/* includes types and type metadata */
#include "../types/var_array_values.h"
#include "../types/var_array_values.h.hexarr"
#include "../types/distribution_name.h"
#include "../types/distribution_name.h.hexarr"


/* block meta information */
char random_walk_cblock_meta[] =
        " { doc='ubx random walk block',"
        "   real-time=true,"
        "}";

/* declaration of block configuration */
ubx_config_t random_walk_cblock_config[] = {
		{ .name="distribution", .type_name = "struct distribution_name", .doc="info about the distribution" },
		{ .name="datacopy", .type_name = "short", .doc="switches between copying data from/to iblock or passing the pointer" },
		{ NULL },
};

/* declaration port block ports */
ubx_port_t random_walk_cblock_ports[] = {
        { .name="new_value", .out_type_name="struct var_array_values", .out_data_len=1, .in_type_name="struct var_array_values", .in_data_len=1, .doc="change of the value of the random walk" },
        { NULL },
};

/* declare a struct port_cache */
struct random_walk_cblock_port_cache {
        ubx_port_t* new_value;
};

/* declare a helper function to update the port cache this is necessary
 * because the port ptrs can change if ports are dynamically added or
 * removed. This function should hence be called after all
 * initialization is done, i.e. typically in 'start'
 */
static void update_port_cache(ubx_block_t *b, struct random_walk_cblock_port_cache *pc)
{
        pc->new_value = ubx_port_get(b, "new_value");
}


///TODO: should be auto-generated or move to core; if auto-gen, then use data type instead of void pointer
int read_port(ubx_port_t *p,const char *type_name, void* data){
	if(p==NULL) { ERR("port is NULL"); return -1; }
	///TODO: check if p is inport
	if(type_name==NULL) { ERR("type_name is NULL"); return -1; }
	ubx_node_info_t* ni = p->block->ni;
	assert(ni!=NULL);
	ubx_type_t *tcheck;
	if((tcheck= ubx_type_get(ni, type_name))==NULL) { ERR("type %s is not known",type_name); return -1; }
	///TODO: which of the checks do make sense and which info should the function get?
	if (tcheck != p->in_type) {
		ERR("port %s type error during read: is '%s' but should be '%s'",
				p->name, type_name, p->in_type_name);
		return -1;
	}
	ubx_data_t val;
	val.type = p->in_type;
	val.data = data;
	val.len = 1;
	return __port_read(p, &val);
}


int write_port(ubx_port_t* p, const char *type_name, void* data)
{
	if(p==NULL) { ERR("port is NULL"); return -1; }
	///TODO: check if p is outport
	if(type_name==NULL) { ERR("type_name is NULL"); return -1; }
	ubx_node_info_t* ni = p->block->ni;
	assert(ni!=NULL);
	ubx_type_t *tcheck;

	if((tcheck= ubx_type_get(ni, type_name))==NULL) { ERR("type %s is not known",type_name); return -1; }
	///TODO: which of the checks do make sense and which info should the function get?
	if (tcheck != p->out_type) {
		ERR("port %s type error during write: is '%s' but should be '%s'", p->name, type_name, p->in_type_name);
		return -1;
	}
	ubx_data_t val;
	val.data = data;
	val.type = p->out_type;
	val.len=1;
	///TODO: shouldn't we check if writing was successful?
	__port_write(p, &val);
	return 0;
}

/* block operation forward declarations */
int random_walk_cblock_init(ubx_block_t *b);
int random_walk_cblock_start(ubx_block_t *b);
void random_walk_cblock_stop(ubx_block_t *b);
void random_walk_cblock_cleanup(ubx_block_t *b);
void random_walk_cblock_step(ubx_block_t *b);

/* helper function */
void create_random_values(struct distribution_name *distr, struct var_array_values *data);

/* put everything together */
ubx_block_t random_walk_cblock_block = {
        .name = "random_walk_cblock",
        .type = BLOCK_TYPE_COMPUTATION,
        .meta_data = random_walk_cblock_meta,
        .configs = random_walk_cblock_config,
        .ports = random_walk_cblock_ports,

        /* ops */
        .init = random_walk_cblock_init,
        .start = random_walk_cblock_start,
        .stop = random_walk_cblock_stop,
        .cleanup = random_walk_cblock_cleanup,
        .step = random_walk_cblock_step,
};

/* random_walk_cblock module init and cleanup functions */
int random_walk_cblock_mod_init(ubx_node_info_t* ni)
{
        DBG(" ");
        int ret = -1;

        if(ubx_block_register(ni, &random_walk_cblock_block) != 0)
                goto out;

        ret=0;
out:
        return ret;
}

void random_walk_cblock_mod_cleanup(ubx_node_info_t *ni)
{
        DBG(" ");
        ubx_block_unregister(ni, "random_walk_cblock");
}

